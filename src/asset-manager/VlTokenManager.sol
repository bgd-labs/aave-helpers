// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import {IERC20} from 'solidity-utils/contracts/oz-common/interfaces/IERC20.sol';
import {SafeERC20} from 'solidity-utils/contracts/oz-common/SafeERC20.sol';

import {QuestVoteType, QuestRewardsType, QuestCloseType, IQuestBoard} from './interfaces/IQuestBoard.sol'; 
import {IVlToken, LockedBalance} from './interfaces/IVlToken.sol';
import {Common} from './Common.sol';

/// @author Llama
abstract contract VlTokenManager is Common {
  using SafeERC20 for IERC20;

  error InvalidSignatureLength();
  error InvalidSignatureS();
  error InvalidSignatureV();
  error InvalidSignature();

  event ClaimVLAURARewards();
  event DelegatedVLAURA(address newDelegate);
  event EmergencyWithdraw(uint256 tokensUnlocked);
  event LockVLAURA(uint256 cummulativeTokensLocked, uint256 lockHorizon);
  event RelockVLAURA(uint256 cumulativeTokensLocked);
  event UnlockVLAURA(uint256 tokensUnlocked);

  address public constant AURA = 0xC0c293ce456fF0ED870ADd98a0828Dd4d2903DBF;
  address public constant VL_AURA = 0x3Fa73f1E5d8A792C80F426fc8F84FBF7Ce9bBCAC;

  address public constant QUESTBOARD_VEBAL = 0xf0CeABf99Ddd591BbCC962596B228007eD4624Ae;
  address public constant QUESTBOARD_DISTRIBUTOR_VEBAL = 0xc413aB9c6d3E60E41a530b0A68817BAeA7bABbEC;
  address public constant DELEGATED_DISTRIBUTOR = 0x997523eF97E0b0a5625Ed2C197e61250acF4e5F1;

  /// @notice Locks specified amount of AURA held in this contract into vlAURA
  /// @param amount The amount of AURA to lock
  function lockVLAURA(uint256 amount) external onlyOwnerOrGuardian {
    IERC20(AURA).forceApprove(VL_AURA, amount);
    IVlToken(VL_AURA).lock(address(this), amount);

    emit LockVLAURA(amount, block.timestamp + IVlToken(VL_AURA).lockDuration());
  }

  /// @notice Claim rewards generated by locking vlAURA
  function claimVLAURARewards() external onlyOwnerOrGuardian {
    IVlToken(VL_AURA).getReward(address(this));

    emit ClaimVLAURARewards();
  }

  /// @notice Delegate vlAURA held to a delegatee
  /// @param delegatee Address of user to delegate to
  function delegateVLAURA(address delegatee) external onlyOwnerOrGuardian {
    IVlToken(VL_AURA).delegate(delegatee);

    emit DelegatedVLAURA(delegatee);
  }

  /// @notice Re-lock vlAURA
  function relockVLAURA() external onlyOwnerOrGuardian {
    (uint256 lockedBalance, , , ) = IVlToken(VL_AURA).lockedBalances(address(this));
    IVlToken(VL_AURA).processExpiredLocks(true);

    emit RelockVLAURA(lockedBalance);
  }

  /// @notice Unlock held vlAURA
  function unlockVLAURA() external onlyOwnerOrGuardian {
    (uint256 lockedBalance, , , ) = IVlToken(VL_AURA).lockedBalances(address(this));
    IVlToken(VL_AURA).processExpiredLocks(false);

    emit UnlockVLAURA(lockedBalance);
  }

  /// @notice Emergency function to withdraw AURA if protocol is shutdown
  function emergencyWithdrawVLAURA() external onlyOwnerOrGuardian {
    (uint256 lockedBalance, , , ) = IVlToken(VL_AURA).lockedBalances(address(this));
    IVlToken(VL_AURA).emergencyWithdraw();

    emit EmergencyWithdraw(lockedBalance);
  }

  function claimQuestBoardRewards() external onlyOwnerOrGuardian {}

  function claimDelegatedQuestBoardRewards() external onlyOwnerOrGuardian {}

   /**
    * @notice Creates a fixed rewards Quest based on the given parameters
    * @dev Creates a Quest based on the given parameters & the given types with the Fixed Rewards type
    * @param gauge Address of the gauge
    * @param rewardToken Address of the reward token
    * @param startNextPeriod (bool) true to start the Quest the next period
    * @param duration Duration of the Quest (in weeks)
    * @param rewardPerVote Amount of reward/vote (in wei)
    * @param totalRewardAmount Total amount of rewards available for the full Quest duration
    * @param feeAmount Amount of fees paid at creation
    * @param voteType Vote type for the Quest
    * @param closeType Close type for the Quest
    * @param voterList List of voters for the Quest (to be used for Blacklist or Whitelist)
    * @return uint256 : ID of the newly created Quest
    */
    function createFixedQuest(
        address gauge,
        address rewardToken,
        bool startNextPeriod,
        uint48 duration,
        uint256 rewardPerVote,
        uint256 totalRewardAmount,
        uint256 feeAmount,
        QuestVoteType voteType,
        QuestCloseType closeType,
        address[] calldata voterList
    ) external onlyOwnerOrGuardian returns (uint256) {
      return IQuestBoard(QUESTBOARD_VEBAL).createFixedQuest(
        gauge,
        rewardToken,
        startNextPeriod,
        duration,
        rewardPerVote,
        totalRewardAmount,
        feeAmount,
        voteType,
        closeType,
        voterList
      );
    }

  /**
   * @notice Creates a ranged rewards Quest based on the given parameters
   * @dev Creates a Quest based on the given parameters & the given types with the Ranged Rewards type
   * @param gauge Address of the gauge
   * @param rewardToken Address of the reward token
   * @param startNextPeriod (bool) true to start the Quest the next period
   * @param duration Duration of the Quest (in weeks)
   * @param minRewardPerVote Minimum amount of reward/vote (in wei)
   * @param maxRewardPerVote Maximum amount of reward/vote (in wei)
   * @param totalRewardAmount Total amount of rewards available for the full Quest duration
   * @param feeAmount Amount of fees paid at creation
   * @param voteType Vote type for the Quest
   * @param closeType Close type for the Quest
   * @param voterList List of voters for the Quest (to be used for Blacklist or Whitelist)
   * @return uint256 : ID of the newly created Quest
   */
  function createRangedQuest(
    address gauge,
    address rewardToken,
    bool startNextPeriod,
    uint48 duration,
    uint256 minRewardPerVote,
    uint256 maxRewardPerVote,
    uint256 totalRewardAmount,
    uint256 feeAmount,
    QuestVoteType voteType,
    QuestCloseType closeType,
    address[] calldata voterList
  ) external onlyOwnerOrGuardian returns (uint256) {
    return IQuestBoard(QUESTBOARD_VEBAL).createRangedQuest(
      gauge,
      rewardToken,
      startNextPeriod,
      duration,
      minRewardPerVote,
      maxRewardPerVote,
      totalRewardAmount,
      feeAmount,
      voteType,
      closeType,
      voterList
    );
  }
}
